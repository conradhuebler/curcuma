#include <algorithm>
#include <fstream>
#include <iostream>
#include <map>
#include <regex>
#include <string>
#include <vector>

// Data structure to hold a parsed parameter definition
struct Parameter {
    std::string module;
    std::string name;
    std::string type;
    std::string defaultValue;
    std::string helpText;
    std::string category;
    std::string aliases;
};

// Function to trim leading/trailing whitespace and quotes
std::string trim(const std::string& str)
{
    const std::string whitespace = " \t\"";
    const auto strBegin = str.find_first_not_of(whitespace);
    if (strBegin == std::string::npos)
        return "";
    const auto strEnd = str.find_last_not_of(whitespace);
    const auto strRange = strEnd - strBegin + 1;
    return str.substr(strBegin, strRange);
}

// Function to generate the C++ header file content - Claude Generated (fixed)
std::string generate_header_content(const std::vector<Parameter>& params)
{
    std::stringstream ss;
    ss << "// THIS FILE IS AUTO-GENERATED BY curcuma_param_parser. DO NOT EDIT MANUALLY.\n\n";
    ss << "#pragma once\n";
    ss << "#include \"src/core/parameter_registry.h\"\n";
    ss << "#include <string>\n\n";
    ss << "// This function will be called to populate the registry\n";
    ss << "inline void initialize_generated_registry() {\n";
    ss << "    auto& registry = ParameterRegistry::getInstance();\n\n";

    for (const auto& p : params) {
        ss << "    registry.addDefinition(\"" << p.module << "\", {\n";
        ss << "        \"" << p.name << "\",\n";
        ss << "        \"" << p.module << "\",\n";
        ss << "        ParamType::" << p.type << ",\n";

        // Type-appropriate default value formatting - Claude Generated
        if (p.type == "String") {
            ss << "        std::string(\"" << p.defaultValue << "\"),\n";
        } else if (p.type == "Bool") {
            ss << "        " << p.defaultValue << ",\n";
        } else {
            // Int or Double - no quotes needed
            ss << "        " << p.defaultValue << ",\n";
        }

        ss << "        \"" << p.helpText << "\",\n";
        ss << "        \"" << p.category << "\",\n";

        // Handle aliases - Claude Generated (Fixed October 2025 - support multiple aliases)
        if (p.aliases.empty()) {
            ss << "        {}\n";
        } else {
            // DON'T trim quotes here - we need them for parsing!
            // Only trim whitespace
            std::string aliases_str = p.aliases;
            // Remove leading/trailing whitespace only (not quotes)
            size_t start = aliases_str.find_first_not_of(" \t");
            size_t end = aliases_str.find_last_not_of(" \t");
            if (start == std::string::npos) {
                ss << "        {}\n";
            } else {
                aliases_str = aliases_str.substr(start, end - start + 1);

                // Parse multiple comma-separated alias strings
                std::vector<std::string> alias_list;
                std::string current_alias;
                bool in_quotes = false;

                for (char c : aliases_str) {
                    if (c == '"') {
                        in_quotes = !in_quotes;
                        // Don't add quotes to the alias string itself
                    } else if (c == ',' && !in_quotes) {
                        // End of one alias, start of next
                        std::string trimmed_alias = trim(current_alias);
                        if (!trimmed_alias.empty()) {
                            alias_list.push_back(trimmed_alias);
                        }
                        current_alias.clear();
                    } else if (in_quotes || (c != ' ' && c != '\t')) {
                        // Add character if inside quotes OR if it's not whitespace outside quotes
                        current_alias += c;
                    }
                }

                // Add last alias
                std::string trimmed_alias = trim(current_alias);
                if (!trimmed_alias.empty()) {
                    alias_list.push_back(trimmed_alias);
                }

                // Generate initializer list
                if (alias_list.empty()) {
                    ss << "        {}\n";
                } else {
                    ss << "        {";
                    for (size_t i = 0; i < alias_list.size(); ++i) {
                        ss << "\"" << alias_list[i] << "\"";
                        if (i + 1 < alias_list.size()) {
                            ss << ", ";
                        }
                    }
                    ss << "}\n";
                }
            }
        }

        ss << "    });\n";
    }

    ss << "}\n";
    return ss.str();
}

int main(int argc, char* argv[])
{
    std::vector<std::string> input_files;
    std::string output_file;

    // 1. Parse command-line arguments
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--inputs" && i + 1 < argc) {
            // Collect all subsequent arguments as input files until another flag is found
            while (i + 1 < argc && argv[i + 1][0] != '-') {
                input_files.push_back(argv[++i]);
            }
        } else if (arg == "--output" && i + 1 < argc) {
            output_file = argv[++i];
        }
    }

    if (output_file.empty()) {
        std::cerr << "Error: --output file path not specified." << std::endl;
        return 1;
    }
    if (input_files.empty()) {
        std::cerr << "Warning: No --inputs specified." << std::endl;
    }

    // 2. Parse all input files
    std::vector<Parameter> all_params;
    std::regex begin_regex(R"(BEGIN_PARAMETER_DEFINITION\s*\(\s*(\w+)\s*\))");
    std::regex end_regex(R"(END_PARAMETER_DEFINITION)");
    // Fixed regex: \"s* â†’ \"\s* (typo fix), added multiline support
    std::regex param_regex(R"(PARAM\s*\(\s*(\w+)\s*,\s*(\w+)\s*,\s*(.*?)\s*,\s*\"(.*?)\"\s*,\s*\"(.*?)\"\s*,\s*\{(.*?)\}\s*\))", std::regex::ECMAScript);

    bool in_param_block = false;
    std::string current_module;

    for (const auto& filepath : input_files) {
        std::ifstream file(filepath);
        if (!file.is_open()) {
            std::cerr << "Warning: Could not open file " << filepath << "\n";
            continue;
        }

        // Read entire file content for multi-line PARAM support - Claude Generated
        std::string file_content((std::istreambuf_iterator<char>(file)),
            std::istreambuf_iterator<char>());
        file.close();

        std::string line;
        std::istringstream stream(file_content);
        int line_number = 0;
        std::string accumulated_line;

        while (std::getline(stream, line)) {
            line_number++;
            std::smatch match;

            // Check for BEGIN block
            if (std::regex_search(line, match, begin_regex)) {
                in_param_block = true;
                current_module = match[1];
                accumulated_line.clear();
                continue;
            }

            // Check for END block
            if (std::regex_search(line, match, end_regex)) {
                in_param_block = false;
                current_module = "";
                accumulated_line.clear();
                continue;
            }

            if (in_param_block) {
                // Accumulate lines for multi-line PARAM definitions
                accumulated_line += " " + line;

                // Try to match complete PARAM definition
                if (std::regex_search(accumulated_line, match, param_regex) && match.size() == 7) {
                    all_params.push_back({
                        current_module,
                        trim(match[1]), // name
                        trim(match[2]), // type
                        trim(match[3]), // defaultValue
                        trim(match[4]), // helpText
                        trim(match[5]), // category
                        std::string(match[6]) // aliases - DON'T trim! We need quotes for parsing
                    });
                    accumulated_line.clear();
                } else if (accumulated_line.find("PARAM") != std::string::npos && accumulated_line.find(')') != std::string::npos && match.size() == 0) {
                    // PARAM found but didn't match - likely syntax error
                    std::cerr << "Warning: Malformed PARAM in " << filepath
                              << " around line " << line_number << "\n";
                    accumulated_line.clear();
                }
            }
        }
    }

    // 3. Generate the header file content
    std::string header_content = generate_header_content(all_params);

    // 4. Write the output file
    std::ofstream out(output_file);
    if (!out.is_open()) {
        std::cerr << "Error: Could not open output file " << output_file << " for writing." << std::endl;
        return 1;
    }
    out << header_content;
    out.close();

    std::cout << "Successfully generated " << output_file << " with " << all_params.size() << " parameter definitions." << std::endl;

    return 0;
}
